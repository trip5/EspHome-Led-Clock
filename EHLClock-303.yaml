# Derived from EHLClock.yaml with yaml-derive.py for 303 Clock - this file is not the master file

# My github: https://github.com/trip5

# Please note that this file can be hand-edited but thanks to simple machine-readable instructions, can also be passed through a script to generate a derivative YAML
# When deriving the YAML for the 303 Clock, the script checks for certain styles of comments and perform actions.  Check the yaml-derive.py script for more information.

substitutions:
  name:  "led-clock-303"
  friendly_name: "LED-Clock-303"
  comment: "EHLClock from Trip5"
  project_name: "Trip5.EspHomeLedClock"
  project_version: "2026.01.25"
  waiting: "EHLC" # shows when waiting for time

  # Time zone must be POSIX format: (ie "KST-9" & "PST8PDT,M3.2.0/2:00:00,M11.1.0/2:00:00" & "AST4ADT,M3.2.0,M11.1.0")
  # A full list can be viewed here: https://github.com/trip5/timezones.json/blob/master/timezones.md
  # If you need to make a custom POSIX format you can look here: https://developer.ibm.com/articles/au-aix-posix/)
  # or even better, use this POSIX Generator (courtesy of TopYuan): https://www.topyuan.top/posix
  time_zone: "AST4ADT,M3.2.0,M11.1.0"

# Pins for I2C RTC are same for Sinilink and 303 Clocks
  scl_pin: GPIO12
  sda_pin: GPIO13
# SPI TM1637 or similar? Specify clk & dio pins here, delete the above 2 lines (if no RTC) and edit the rest of the file carefully!
#  clk_pin: GPIO16
#  dio_pin: GPIO17

# Mappings are the order of the LED segments. Using the wrong mapping will result in a garbled display!
  segment_mapping: GBPEDCAF
# TM1637 units don't actually use segment mapping but the routines that make the colon blink depend on it being specified (PM dot is ignored by the hardware)
#  segment_mapping: PABCDEFG # TM1637 / normal TM1650 (untested, may not support colon or decimals)

  backward: 'false'
# Upside-down display? Use one of these and change above line to backward: 'true'
#  segment_mapping: PDCBGFEA # Upside-down Sinilink XY-Clock
#  segment_mapping: GDCABPEF # Upside-down 303WIFILC01
#  segment_mapping: PDEFABCG # To use with TM1650 (untested)
#  * if there is another segment_mapping to use, it's quite simple to change a regular mapping to an upside-down one...
#  * The rule is actually fairly simple. Take 2nd, 3rd, 4th and switch with 5th, 6th, 7th in order (TM1650 pattern is easy: PABCDEFG -> PDEFABCG)

  down_button_pin: GPIO15
  up_button_pin: GPIO4
  set_button_pin: GPIO0

  status_led_pin: GPIO2

# The following are for the tunes played by the alarm through the passive piezo speaker / buzzer on the Sinilink clock - remove if not needed
# You can check here: https://picaxe.com/rtttl-ringtones-for-tune-command/ or Search for "RTTTL tunes" to change the tunes

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  comment: "${comment}"
  project:
    name: "${project_name}"
    version: "${project_version}"
  on_boot:
    - priority: 600
      then:
        - globals.set:
            id: segmentmap
            value: !lambda 'return "${segment_mapping}";'
        - lambda: 'id(display_off) = false;'
        - ds1302.read_time:

esp8266:
  board: esp8285
  restore_from_flash: true
  
wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  reboot_timeout: 0s # reboot if no wifi (must be disabled for wifi to be turned off)
  enable_on_boot: true
  id: wifi_id
  ap:
    ssid: ${name}
    password: !secret ap_password
    ap_timeout: 10s # this has to be short, especially if using Stop Seek Wifi
  on_connect:
    - logger.log: "Wifi connected"
    - light.turn_off: led1
    - lambda: 'id(wifi_stop_seek_time_count) = 0;'
    - delay: 2s
    - if:
        condition:
          lambda: 'return id(wifi_ip).state != "192.168.4.1";'
        then:
          - button.press: display_ip
    - script.execute: sync_the_time
  on_disconnect:
    - if:
        condition:
          - switch.is_on: wifi_stop_seek
        then:
          - logger.log: "Wifi disconnected - will be disabled soon (stop seek is on)..."
        else:
          - logger.log: "Wifi disconnected"
    - delay: 1s
    - button.press: display_ip

external_components:
# Use Trip5's fork of Buzzer13's TM1650 ESPHome Component
  - source:
      type: git
      url: https://github.com/trip5/esphome-tm1650
      ref: main
    refresh: 60s
    components: [ tm1650 ]
# Prefer a local source (only use one source)
#  - source:
#      type: local
#      path: my-components/EHCL-Clock # e.g. /config/esphome/components
#    components: [ tm1650 ]
#    refresh: 1s

  - source:
      type: git
      url: https://github.com/trip5/esphome-ds1302
      ref: main
    refresh: 60s
    components: [ ds1302 ]

time:
  - platform: sntp # use SNTP as a time source / do not use Home Assistant!
    id: my_time
    timezone: "${time_zone}"
    update_interval: 24h # This seems like the longest safe amount of time - actual configured update happens in interval section

# Check if alarms need to be played (needs to be under whichever platform is my_time) - remove if alarms are not needed


  - platform: ds1302
    id: rtc_time
    cs_pin: GPIO5
    dio_pin: GPIO14
    clk_pin: GPIO16
    update_interval: never
    timezone: "${time_zone}"

script:
  - id: sync_the_time
    mode: restart
    then:
      - wait_until:
          condition: wifi.connected
      - lambda: |-
          ESP_LOGI("info", "Sync the Time");
      - lambda: 'id(my_time)->update();'
      - ds1302.write_time:
# If no RTC is being used, delete above write_time lines and delete 4 lines in the below script - they start with id(rtc_time)
  - id: set_timezone
    mode: restart
    then:
      - delay: 250ms # need states to stick before updating (helps prevent crashes, too)
      - lambda: |-
          if (id(alt_time_zone_on).state && !id(alt_timezone).state.empty()) {
            id(my_time)->set_timezone(id(alt_timezone).state.c_str());
            id(rtc_time)->set_timezone(id(alt_timezone).state.c_str());
          } else {
            id(my_time)->set_timezone(("${time_zone}"));
            id(rtc_time)->set_timezone("$(time_zone}");
          }
          //id(my_time)->call_setup(); // might be needed?
  - id: display_off_activate
    mode: restart
    then:
      - lambda: |-
          ESP_LOGI("info", "Display Off activated");
          id(display_off) = true;
  - id: display_off_deactivate
    mode: restart
    then:
      - lambda: |-
          ESP_LOGI("info", "Display Off deactivated");
          id(display_off_time_count) = 0;
          id(display_off) = false;


# Enable Home Assistant API
api:
  # delete next 2 lines if not using HA API encryption
  encryption:
    key: !secret encryption_key
  reboot_timeout: 0s # Must be disabled to allow the Wifi enable/disable to function

mdns:
  disabled: false

logger:
  level: NONE
# Logging is disabled to save memory but you can easily enable logging (and stop the various sensors/switches from spamming the log) by deleting the above line and uncommenting the lines below
# Note that increasing the level uses up memory (which this device has very little available) and may cause errors and/or crashing - please note it's also disabled in the web_server section
#  level: INFO
#  logs:
#    sensor: ERROR
#    text_sensor: NONE
#    switch: NONE
#    light: NONE
#    number: NONE
#    rtttl: NONE

web_server:
  port: 80
  # ota: false # true by default
  include_internal: false # true will expose more than needed to the Web UI
  version: 2 # version 3 is much larger but possible if local is false
  local: true # will download www.js and serve it directly from the clock
  log: false # disabling in the WebUI to save memory

ota:
  - platform: esphome
    password: !secret ota_password
    on_begin:
      then:
        - lambda: |-
            id(display_off_time_count) = 0;
            id(display_off) = false;
            id(message) = ("OtA");
            id(message_alive_time) = 100;
            id(message_display_time) = 100;
            id(message_clock_time) = 0;
            id(tm_display)->update();
        - logger.log: "OTA Update started."
    on_progress:
      then:
        - lambda: |-
            id(display_off_time_count) = 0;
            id(display_off) = false;
            id(message) = "=" + std::to_string((int)x) + "=";
            if (x > 9) { id(tm_display)->update(); }
        - logger.log:
            format: "OTA progress %0.1f%%"
            args: ["x"]
    on_end:
      then:
        - lambda: |-
            id(display_off_time_count) = 0;
            id(display_off) = false;
            id(message) = "done";
            id(tm_display)->update();
        - logger.log: "OTA end"
    on_error:
      then:
        - lambda: |-
            id(display_off_time_count) = 0;
            id(display_off) = false;
            id(message) = "Eror";
            id(tm_display)->update();
        - logger.log:
            format: "OTA update error %d"
            args: ["x"]

captive_portal:

improv_serial:

text_sensor:
  - platform: wifi_info
    ip_address:
      id: wifi_ip
      name: "IP Address"
      entity_category: diagnostic
      icon: mdi:network
      disabled_by_default: true
  - platform: template
    id: project_version
    name: "${project_name} Version"
    lambda: 'return {"${project_version}"};'
    entity_category: diagnostic
    icon: mdi:github
    disabled_by_default: true

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifisignal
    update_interval: 30s
    unit_of_measurement: "dBm"
    entity_category: "diagnostic"
    icon: mdi:wifi
    disabled_by_default: true

output:
  - platform: esp8266_pwm # ESP32 use platform: ledc
    id: statusled
    pin:
      number: ${status_led_pin}
      inverted: true


light:
  - platform: monochromatic
    id: led1
    name: "LED"
    output: statusled
    internal: true

# Sinilink has 2 LEDs and this will remap the 2nd LED as a status LED but its blinking can be distracting so I've commented it out / 303 Clock can't use it
#status_led:
#  pin:
#    number: ${other_led_pin}
#    inverted: true

preferences:
  flash_write_interval: 15s # 0 does immediate write to memory with no mem buffer (not recommended) (only saves when persistent variables have changed)

i2c:
  sda: ${sda_pin}
  scl: ${scl_pin}
  scan: true
  id: i2cbus
  
# Check this section carefully!
# Also, some info how to handle multi_click options: https://community.home-assistant.io/t/esphome-button-held-double-press/136083/10
binary_sensor:
  - platform: status
    name: "Status"
  - platform: gpio
    pin:
      number: ${up_button_pin}
      inverted: true # Sinilink true / 303 true
      mode: INPUT_PULLUP
    name: "Up button"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_multi_click:
      #Click UP will increase brightness
      - timing:
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          if:
            condition:
              - lambda: 'return id(display_off);'
            then:
              - script.execute: display_off_deactivate
            else:
              - number.increment: brightness
      #Hold UP will toggle the wifi timeout
      - timing:
          - ON for at least 1s
        then:
          if:
            condition:
              - lambda: 'return id(display_off);'
            then:
              - script.execute: display_off_deactivate
            else:
              - switch.toggle: wifi_stop_seek
  - platform: gpio
    pin:
      number: ${down_button_pin}
      inverted: false
      mode: INPUT_PULLUP
    name: "Down button"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_multi_click:
      #Click DOWN will decrease brightness
      - timing:
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          if:
            condition:
              - lambda: 'return id(display_off);'
            then:
              - script.execute: display_off_deactivate
            else:
              - number.decrement: brightness
      #Hold DOWN will select enable or disable time zone offset
      - timing:
          - ON for at least 1s
        then:
          if:
            condition:
              - lambda: 'return id(display_off);'
            then:
              - script.execute: display_off_deactivate
            else:
              - switch.toggle: tzoffset_on
  - platform: gpio
    pin: 
      number: ${set_button_pin}
      inverted: true # Sinilink true / 303 true
      # mode: INPUT_PULLUP # may need to uncomment this on another clock?
    name: "Set button"
    filters:
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_multi_click:
      #Click SET will toggle 12-hour mode
      - timing:
          - ON for at most 0.5s
          - OFF for at least 0.5s
        then:
          if:
            condition:
              - lambda: 'return id(display_off);'
            then:
              - script.execute: display_off_deactivate
            else:
              - switch.toggle: hour12_mode
      #Hold SET will show the IP Address
      - timing:
          - ON for at least 1s
        then:
          - button.press: display_ip

# This section contains a lot of lambda code... if using the Sinilink or 303, you shouldn't have to edit this at all
# If using something else, you may need to edit the segmentmap sections (conveniently 'if' sections), depending on how the decimals/colons are handled
# If that's true, get back to me on github by opening an issue and help contribute to other displays this YAML can handle!
# If using a TM1637, you should change the platform to tm1637 and check a few lines just below here
display:
  - platform: tm1650
    id: tm_display
    update_interval: 1s
    length: 4
    backward: ${backward}
    segment_map: ${segment_mapping}
    i2c_id: i2cbus
    # TM1637: remove the above 3 lines and uncomment the next 2 lines
    # clk_pin: ${clk_pin}
    # dio_pin: ${dio_pin}
    # If you are using either the Sinilink or 303, there should be no need to edit anything inside this lambda below!
    lambda: |-
      // Display the message if all conditions are met
      if (id(my_time).now().is_valid() && !id(display_off)) {
        if ((id(message_alive_time) != 0) && (id(message_clock_time_count) >= id(message_clock_time))) {
          id(message_display_time_count) += 1;
          id(message_alive_time_count) += 1;
          auto message_text = id(message);
          it.print(0, message_text.c_str());
          if (id(message_display_time_count) >= id(message_display_time)) {
            id(message_display_time_count) = 0;
            id(message_clock_time_count) = 0;
            if (id(message_alive_time_count) >= id(message_alive_time)) {
              id(message_alive_time_count) = 0;
              id(message_alive_time) = 0;
              ESP_LOGI("info", "Message Alive Time finished.");
            }
          }
        } else {
            if ((id(message_alive_time) != 0) && (id(message_clock_time) != 0)) {
              id(message_clock_time_count) += 1;
              id(message_alive_time_count) += 1;
            }
            static int blinking = false;
            // apply offset if needed https://community.home-assistant.io/t/multiple-time-zones/435315/12
            int offset = 0;
            if (id(tzoffset_on).state != false) {
              offset = (int)(60*60*(id(tzoffset).state));
            }
            std::time_t tz1time = (id(my_time).now().timestamp + offset);
            std::tm *tz1time_astm = localtime(&tz1time);
            // check if the date should be displayed
            if ((id(time_display_count) >= (id(time_display_time).state)) && (id(date_display_mode).state != false)) {
              id(date_display_count) += 1;
              // display date
              int tzmon = (tz1time_astm->tm_mon) + 1;
              int tzmday = tz1time_astm->tm_mday;
              std::string timemon_text = std::to_string(tzmon);
              std::string timemday_text = std::to_string(tzmday);
              std::string mon_a = (timemon_text.substr(0,1).c_str());
              std::string mon_b = (timemon_text.substr(1,1).c_str());
              std::string mday_a = (timemday_text.substr(0,1).c_str());
              std::string mday_b = (timemday_text.substr(1,1).c_str());
              if (tzmon < 10) {
                mon_b = mon_a;
                mon_a = "0";
              }
              if (tzmday < 10) {
                mday_b = mday_a;
                mday_a = "0";
              }
              if (id(date_display_mode_us).state != false) {
                it.print(0, mday_a.c_str());
                it.print(1, mday_b.c_str());
                it.print(2, mon_a.c_str());
                it.print(3, mon_b.c_str());
              } else {
                it.print(0, mon_a.c_str());
                it.print(1, mon_b.c_str());
                it.print(2, mday_a.c_str());
                it.print(3, mday_b.c_str());
              }
              if (id(date_display_count) >= id(date_display_time).state) {
                id(time_display_count) = 0;
              }
            } else {
              // display time
              id(date_display_count) = 0;
              id(time_display_count) += 1;
              int tzhr = tz1time_astm->tm_hour;
              int tzmin = tz1time_astm->tm_min;
              std::string timeh_text = std::to_string(tzhr);
              std::string timem_text = std::to_string(tzmin);
              std::string hour_a = (timeh_text.substr(0,1).c_str());
              std::string hour_b = (timeh_text.substr(1,1).c_str());
              std::string min_a = (timem_text.substr(0,1).c_str());
              std::string min_b = (timem_text.substr(1,1).c_str());
              if (tzmin < 10) {
                min_b = min_a;
                min_a = "0";
              }
              if (id(hour12_mode).state == true) {
                if (tzhr > 12) {
                  timeh_text = std::to_string((tz1time_astm->tm_hour) - 12);
                  hour_a = (timeh_text.substr(0,1).c_str());
                  hour_b = (timeh_text.substr(1,1).c_str());
                }
                if ((tzhr < 22 && tzhr > 12) || (tzhr < 10)) {
                  hour_b = hour_a;
                  hour_a = " ";
                }
                if (tzhr == 0) {
                  hour_a = "1";
                  hour_b = "2";
                }
                if (tzhr > 11) {
                  if (id(segmentmap) == "GBPEDCAF") {
                    min_b.append("."); // the 303 can have a decimal after the 4th digit to indicate PM
                  }
                  if (id(segmentmap) == "GDCABPEF") {
                    hour_a.append("."); // the 303 can have a decimal after the 4th digit to indicate PM (flipped!)
                  }
                  if (id(segmentmap) == "PGFEDCBA") {
                    hour_b.append("."); // the Sinilink can have a decimal after the 2nd digit to indicate PM
                  }
                  if (id(segmentmap) == "PDCBGFEA") {
                    min_a.append("."); // the Sinilink can have a decimal after the 2nd digit to indicate PM (flipped!)
                  }
                }
              } else {
                if (tzhr < 10) {
                  hour_b = hour_a;
                  hour_a = "0";
                }
              }
              if (((++blinking & 1) && (id(blink_option) == 1)) || (id(blink_option) == 2)) {
                if (id(segmentmap) == "GBPEDCAF") {
                  hour_b.append("."); // the 303 requires a period between the 2nd and 3rd digit to activate the colon
                }
                if (id(segmentmap) == "GDCABPEF") {
                  min_a.append("."); // the 303 requires a period between the 2nd and 3rd digit to activate the colon (flipped!)
                }
                if (id(segmentmap) == "PGFEDCBA") {
                  min_a.append(".");
                  min_b.append("."); // the Sinilink requires periods after the 3rd and 4th digits to activate the colon
                }
                if (id(segmentmap) == "PDCBGFEA") {
                  hour_a.append(".");
                  hour_b.append("."); // the Sinilink requires periods after the 3rd and 4th digits to activate the colon (flipped!)
                }
                if (id(segmentmap) == "PABCDEFG") {
                  hour_b.append("."); // the TM1637 requires a period between the 2nd and 3rd digit to activate the colon (flipped can't do it)
                }
              }
              it.print(0, hour_a.c_str());
              it.print(1, hour_b.c_str());
              it.print(2, min_a.c_str());
              it.print(3, min_b.c_str());
          }
        }
      } else {
        if (!id(display_off)) {
          it.print("${waiting}");
        }
      }
      // This next bit handles the display_off stuff
      if (id(display_off)) {
        it.print(0, "    ");
        it.set_intensity(0);
      } else {
        it.set_intensity(id(brightness).state);
      }

interval:
  - interval: 1min # check if the time should be synced, and if so, do it
    then:
      - lambda: |-
          id(sync_time_count) += 1;
          if (id(sync_time_count) >= (id(sync_time).state * 60)) {
            id(sync_time_count) = 0;
            if (id(wifi_id).is_connected()) {
              id(sync_the_time).execute();
            }
          }
  - interval: 1s # check if the wifi should be turned off, and if so, do it (or turn on if stop seek has been disabled) and blink led while seeking wifi
    then:
      - lambda: |-
          if (id(wifi_stop_seek).state == true && !id(wifi_id).is_connected() && !id(wifi_id).is_disabled()){
            id(wifi_stop_seek_time_count) += 1;
            if (id(wifi_stop_seek_time_count) >= id(wifi_stop_seek_time).state) {
              id(wifi_stop_seek_time_count) = 0;
              id(wifi_id)->disable();
              id(display_ip).press();
            }
          }
          if (id(wifi_stop_seek).state == false && id(wifi_id).is_disabled()) {
            id(wifi_stop_seek_time_count) = 0;
            id(wifi_id)->enable();
            id(display_ip).press();
          }
          if (!id(wifi_id).is_connected() && !id(wifi_id).is_disabled()) {
            id(seek_blink_led) += 1;
            if (id(wifi_stop_seek).state == false) {
              if (id(seek_blink_led) % 1 == 0) {
                auto call = id(led1).toggle();
                call.perform();
              }
            } else {
              if (id(seek_blink_led) % 2 == 0) {
                auto call = id(led1).toggle();
                call.perform();
              }
            }
          }
          if (id(led1).current_values.is_on() && (id(wifi_id).is_connected() || id(wifi_id).is_disabled())) {
              auto call = id(led1).turn_off();
              call.perform();
          }
          if (id(my_time).now().is_valid() && !id(display_off)) {
            if (id(display_off_no_wifi_time).state != 0 || id(display_off_time).state != 0) {
              id(display_off_time_count) = id(display_off_time_count) + 1;
            }
            if ((id(display_off_time).state != 0 && id(display_off_time_count) >= (id(display_off_time).state * 60)) || (id(display_off_no_wifi_time).state != 0 && id(display_off_time_count) >= id(display_off_no_wifi_time).state && (!id(wifi_id).is_connected() || id(wifi_id).is_disabled()))) {
              id(display_off_activate).execute();
            }
          }

globals:
  - id: message
    type: std::string
    restore_value: false
    initial_value: ''
  - id: message_display_time
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: message_clock_time
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: message_alive_time
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: message_display_time_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: message_clock_time_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: message_alive_time_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: segmentmap
    type: std::string
    restore_value: false
    initial_value: ''
  - id: IPAddressA
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: IPAddressB
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: IPAddressC
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: IPAddressD
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: blink_option
    type: uint8_t
    restore_value: true
    initial_value: '1'
  - id: time_display_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: date_display_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: sync_time_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
# Wifi Stop Seek Variables
  - id: wifi_stop_seek_time_count
    type: uint8_t
    restore_value: false
    initial_value: '0'
  - id: seek_blink_led
    type: uint8_t
    restore_value: false
    initial_value: '0'
# Display Off Variables
  - id: display_off
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: display_off_time_count
    type: uint16_t
    restore_value: false
    initial_value: '0'

text:
  - platform: template
    name: "Alt Time Zone POSIX"
    id: alt_timezone
    optimistic: true
    min_length: 0
    max_length: 35
    mode: text
    restore_value: true
    initial_value: "${time_zone}"
    on_value:
      then:
        - delay: 250ms
        - lambda: |-
            if (id(alt_timezone).state == "") {
              id(alt_timezone).state = "${time_zone}";
            }
            if (id(alt_timezone).state == "${time_zone}") {
              id(alt_time_zone_on).turn_off();
            } else {
              if (id(tzoffset_on).state) {
                id(tzoffset_on).turn_off();
              }
              id(alt_time_zone_on).turn_on();
            }
        - script.execute: set_timezone
    entity_category: config
    icon: mdi:clock
    disabled_by_default: true


button:
  - platform: template
    id: display_ip
    name: "Display IP Address"
    internal: true
    on_press:
      - if:
          condition:
            not:
              wifi.connected:
          then:
            - lambda: |-
                if (id(wifi_id).is_disabled()) {
                  id(message) = ("Off");
                } else {
                  id(message) = ("noIP");
                }
                id(message_alive_time) = 3;
                id(message_display_time) = 3;
                id(message_clock_time) = 0;
          else:
            - lambda: |-
                int IPA, IPB, IPC, IPD;
                sscanf((id(wifi_ip).state.c_str()), "%d.%d.%d.%d", &IPA, &IPB, &IPC, &IPD);
                id(IPAddressA) = IPA;
                id(IPAddressB) = IPB;
                id(IPAddressC) = IPC;
                id(IPAddressD) = IPD;
                id(message) = "IP";
                id(message_alive_time) = 100;
                id(message_display_time) = 100;
                id(message_clock_time) = 0;
            - delay: 2s
            - lambda: 'id(message) = to_string(id(IPAddressA));'
            - delay: 2s
            - lambda: 'id(message) = to_string(id(IPAddressB));'
            - delay: 2s
            - lambda: 'id(message) = to_string(id(IPAddressC));'
            - delay: 2s
            - lambda: 'id(message) = to_string(id(IPAddressD));'
            - delay: 2s
            - lambda: |-
                id(message_alive_time) = 0;
                id(message_display_time) = 0;
  - platform: template
    id: reset_timezone_text
    name: "Alt Time Zone Reset to ${time_zone}"
    on_press:
      then:
        - lambda: |-
            auto call = id(alt_timezone).make_call();
            call.set_value("${time_zone}");
            call.perform();
    entity_category: config
    icon: mdi:clock-alert

# Tune Buttons (edit as needed, verify the selector below matches the number available)

switch:
  - platform: template
    name: "12 Hour Mode"
    id: hour12_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - lambda: |-
            ESP_LOGI("info", "12 Hour Mode On");
    turn_off_action:
        - lambda: |-
            ESP_LOGI("info", "12 Hour Mode Off");
    entity_category: config
    icon: mdi:clock-digital
  - platform: template
    name: "Date Display US Mode (DDMM)"
    id: date_display_mode_us
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - lambda: |-
            ESP_LOGI("info", "Date Display US Mode On");
    turn_off_action:
        - lambda: |-
            ESP_LOGI("info", "Date Display US Mode Off");
    entity_category: config
    icon: mdi:calendar-month
  - platform: template
    name: "Time Zone Offset On"
    id: tzoffset_on
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - lambda: |-
            ESP_LOGI("info", "Time Zone Offset On");
    turn_off_action:
        - lambda: |-
            ESP_LOGI("info", "Time Zone Offset Off");
    entity_category: config
    icon: mdi:airplane-clock
  - platform: template
    name: "Date Display Mode"
    id: date_display_mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - logger.log: "Date Display Mode On"
        - lambda: |-
            id(message) = ("dton");
            id(message_alive_time) = 1;
            id(message_display_time) = 1;
            id(message_clock_time) = 0;
    turn_off_action:
        - logger.log: "Date Display Mode Off"
        - lambda: |-
            id(message) = ("doff");
            id(message_alive_time) = 1;
            id(message_display_time) = 1;
            id(message_clock_time) = 0;
    entity_category: config
    icon: mdi:calendar
  - platform: template
    name: "Wifi Stop Seek"
    id: wifi_stop_seek
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - delay: 1s
        - logger.log: "Wifi Stop Seek On"
        - lambda: |-
            id(message) = ("stop");
            id(message_alive_time) = 1;
            id(message_display_time) = 1;
            id(message_clock_time) = 0;
    turn_off_action:
        - delay: 1s
        - logger.log: "Wifi Stop Seek Off"
        - lambda: |-
            id(message) = ("seeH");
            id(message_alive_time) = 1;
            id(message_display_time) = 1;
            id(message_clock_time) = 0;
    entity_category: config
    icon: mdi:wifi-off
  - platform: template
    name: "Alt Time Zone On"
    id: alt_time_zone_on
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
        - lambda: |-
            ESP_LOGI("info", "Alt Time Zone On");
    turn_off_action:
        - lambda: |-
            ESP_LOGI("info", "Alt Time Zone Off");
    entity_category: config
    icon: mdi:airplane-clock

# Alarms On/Off Selector: in theory, you could edit this and duplicate it to turn individual alarms on and off (you'd have to edit the on_time section and add global variables)

select:
  - platform: template
    name: "Colon Blink (0=Off / 1=On / 2=Always On)"
    id: blink_option_select
    restore_value: true
    optimistic: true
    options:
      - '0'
      - '1'
      - '2'
    initial_option: '1'
    on_value:
      then:
        - lambda: |-
            id(blink_option) = atoi(x.c_str());
            ESP_LOGI("info", "Colon Blink: %d", id(blink_option));
    entity_category: config
    icon: mdi:shimmer

number:
  - platform: template
    name: "Brightness"
    id: brightness
    restore_value: true
    optimistic: true
    step: 1
    min_value: 0
    max_value: 8
    initial_value: 1
    mode: slider
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Brightness: %.0f", x);
    entity_category: config
    icon: mdi:brightness-5
  - platform: template
    name: "Time Display Time"
    id: time_display_time
    restore_value: true
    optimistic: true
    step: 1
    min_value: 1
    max_value: 60
    initial_value: 8
    mode: box
    unit_of_measurement: seconds
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Time Display Time: %.0f seconds", x);
    entity_category: config
    icon: mdi:clock-start
  - platform: template
    name: "Date Display Time"
    id: date_display_time
    restore_value: true
    optimistic: true
    step: 1
    min_value: 1
    max_value: 60
    initial_value: 2
    mode: box
    unit_of_measurement: seconds
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Date Display Time: %.0f seconds", x);
    entity_category: config
    icon: mdi:calendar-start
  - platform: template
    name: "Time Zone Offset"
    id: tzoffset
    restore_value: true
    optimistic: true
    step: 0.25
    min_value: -26
    max_value: 26
    initial_value: 0
    mode: box
    unit_of_measurement: hours
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Time Zone Offset: %.2f hours", x);
    entity_category: config
    icon: mdi:clock-plus
  - platform: template
    name: "Time Sync Interval"
    id: sync_time
    restore_value: true
    optimistic: true
    step: 1
    min_value: 1
    max_value: 24
    initial_value: 8
    mode: box
    unit_of_measurement: hours
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Time Sync Interval: %.0f hours", x);
    entity_category: config
    icon: mdi:timer-sync
  - platform: template
    name: "Wifi Stop Seek Time"
    id: wifi_stop_seek_time
    restore_value: true
    optimistic: true
    step: 1
    min_value: 1
    max_value: 60
    initial_value: 180
    mode: box
    unit_of_measurement: seconds
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Wifi Stop Seek Time: %.0f seconds", x);
    entity_category: config
    icon: mdi:wifi-off
  - platform: template
    name: "Display Off Time (0 Disable)"
    id: display_off_time
    restore_value: true
    optimistic: true
    step: 5
    min_value: 0
    max_value: 60
    initial_value: 0
    mode: box
    unit_of_measurement: minutes
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Display Off Time: %.0f minutes", x);
        - script.execute: display_off_deactivate
    entity_category: config
    icon: mdi:lightbulb-off
  - platform: template
    name: "Display Off When No Wifi Time (seconds) (0 Disable)"
    id: display_off_no_wifi_time
    restore_value: true
    optimistic: true
    step: 5
    min_value: 0
    max_value: 180
    initial_value: 60
    mode: box
    unit_of_measurement: seconds
    set_action:
      then:
        - lambda: |-
            ESP_LOGI("info", "Display Off No Wifi Time: %.0f seconds", x);
        - script.execute: display_off_deactivate
    entity_category: config
    icon: mdi:lightbulb-off


